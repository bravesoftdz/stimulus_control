unit glbackground;

{$mode objfpc}{$H+}

interface

uses
  {$IFDEF LCLGTK2}
  gtk2, gdk2, //glib2,
  {$ENDIF}
  Classes, SysUtils, FileUtil, Forms, Controls, Graphics,
  Dialogs

, Math
, OpenGLContext
, gl
, draw_methods
;

type

  { TglForm }

  TglForm = class(TForm)
    glBkgnd: TOpenGLControl;
    procedure FormCreate(Sender: TObject);
    procedure FormResize(Sender: TObject);
    procedure glBkgndKeyPress(Sender: TObject; var Key: char);
    procedure glBkgndPaint(Sender: TObject);
    procedure glBkgndResize(Sender: TObject);
  private
    FFullScreen : Boolean;
    FOriginalBounds: TRect;
    FOriginalWindowState: TWindowState;
    FScreenBounds: TRect;
  public
    procedure gResize;
    procedure SetFullScreen(TurnOn : Boolean);
  end;

var
  glForm: TglForm;

implementation

{$R *.lfm}

{ TglForm }

procedure TglForm.glBkgndPaint(Sender: TObject);
var radius, x, y : GlDouble; angle, i : integer;
begin
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity;
  glOrtho(0, Screen.Width, Screen.Height, 0,0, 1);
  glMatrixMode (GL_MODELVIEW);
  glDisable(GL_DEPTH_TEST);
  glClear(GL_COLOR_BUFFER_BIT);

  //glEnable( GL_LINE_SMOOTH );
  //glHint( GL_LINE_SMOOTH_HINT, GL_NICEST );
    glBegin( GL_LINES );

      //glBegin(GL_LINE_S);

      glVertex2f(-1, 1);
      glVertex2f(0, 0);
    glEnd;

    glBegin(GL_LINE_LOOP);
    x := 500;
    y := 500;
    radius := 100;

    angle := 1;
    for i := 0 to 50 do
      begin
      glVertex2f(x + (Sin(angle) * radius), y + (Cos(angle) * radius));
      Inc(angle, 1);
      end;


    glEnd;
  glBkgnd.SwapBuffers;
end;

procedure TglForm.glBkgndResize(Sender: TObject);
begin

end;

procedure TglForm.gResize;
begin
  glViewport(0, 0, Width, Height);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity;

  glOrtho(0, Width, Height, 0,0, 1);

  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity;
end;

procedure TglForm.FormCreate(Sender: TObject);
begin

end;

procedure TglForm.FormResize(Sender: TObject);
begin

end;


procedure TglForm.glBkgndKeyPress(Sender: TObject; var Key: char);
begin
  if key in ['a', 'A'] then
    begin
      SetFullScreen(not FFullScreen);

    end;
end;

procedure TglForm.SetFullScreen(TurnOn: Boolean);
begin
  if TurnOn then
    begin
      // To full screen
      FOriginalWindowState := WindowState;
      FOriginalBounds := BoundsRect;

      BorderStyle := bsNone;
      FScreenBounds := Screen.MonitorFromWindow(Handle).BoundsRect;
    with FScreenBounds do
      SetBounds(Left, Top, Right - Left, Bottom - Top);
      {$IFDEF WINDOWS}
        Application.ShowInTaskBar := False;
      {$ENDIF}

      {$IFDEF LCLGTK2}
      gdk_window_fullscreen(PGtkWidget(Self.Handle)^.window);
      {$ENDIF}
      gResize;
    end
  else
    begin
      {$IFDEF MSWINDOWS}
      BorderStyle := bsSizeable;
      {$ENDIF}

      if FOriginalWindowState = wsMaximized then
        WindowState := wsMaximized
      else
        with FOriginalBounds do
          SetBounds(Left, Top, Right - Left, Bottom - Top);

      {$IFDEF LINUX}
      BorderStyle := bsSizeable;
      {$ENDIF}

      {$IFDEF LCLGTK2}
      gdk_window_unfullscreen(PGtkWidget(Self.Handle)^.window);
      {$ENDIF}
      gResize;
    end;
  FFullScreen := TurnOn;
end;

end.

